
; 64tass Turbo Assembler Macro V1.54.1864? listing file
; 64tass -b -C -L E64_kernel.lst -o E64_kernel.bin E64_kernel.asm
; Sat Sep  7 22:08:08 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: E64_kernel.asm


;******  Processing file: E64_kernel_constants.asm

=$00						cursor_pos = $00
=$f0						P0 = $f0
=$f2						P1 = $f2
=$f4						P2 = $f4
=$f6						P3 = $f6
=$f8						P4 = $f8
=$fa						P5 = $fa
=$fc						P6 = $fc
=$fe						P7 = $fe
=$0300						CIA_BASE = $0300
=$0400						VICV_BASE = $0400
=1024						VICV_BO = VICV_BASE + $00
=1025						VICV_BG = VICV_BASE + $01
=1026						VICV_TSL = VICV_BASE + $02
=1027						VICV_TSH = VICV_BASE + $03
=1028						VICV_CSL = VICV_BASE + $04
=1029						VICV_CSH = VICV_BASE + $05
=$0500						SID_BASE = $0500
=$00						ASCII_NULL	= $00
=$08						ASCII_BKSPC	= $08
=$0a						ASCII_LF	= $0a
=$0d						ASCII_CR	= $0d
=$20						ASCII_SPACE	= $20
=$7f						ASCII_DEL	= $7f

;******  Return to file: E64_kernel.asm

.e000					cold_start:
.e000	a2 ff		ldx #$ff		ldx #$ff	; prepare large stack at $dfff
.e002	a0 df		ldy #$df		ldy #$df
.e004	9a		txs			txs		; move x into sl
.e005	2b		tys			tys		; move y into sh
.e006	02		cle			cle		; clear extended mode flag to enable large stack
.e007	a9 01		lda #$01		lda #$01	; set bit 0 in accumulator
.e009	0c 01 03	tsb $0301		tsb CIA_BASE+1	; turn on keyboard interrupt generation by CIA
.e00c	58		cli			cli		; clear irq disable flag (enable irqs)
.e00d	a9 06		lda #$06		lda #$06	; blue for background
.e00f	8d 01 04	sta $0401		sta VICV_BG
.e012	a9 00		lda #$00		lda #$00	; black for border
.e014	8d 00 04	sta $0400		sta VICV_BO
.e017	8d 03 04	sta $0403		sta VICV_TSH	; point vicv to text and color screen (assert accum. contains $00)
.e01a	8d 05 04	sta $0405		sta VICV_CSH
.e01d	a9 18		lda #$18		lda #$18
.e01f	8d 02 04	sta $0402		sta VICV_TSL
.e022	1a		inc a			inc a
.e023	8d 04 04	sta $0404		sta VICV_CSL
.e026	20 a9 e0	jsr $e0a9		jsr clear_screen
.e029	f4 f7 e0	phw #$e0f7		phw #welc1	; push the address of the first welcome message onto the stack
.e02c	20 e9 e0	jsr $e0e9		jsr put_string
.e02f	f4 0f e1	phw #$e10f		phw #welc2
.e032	20 e9 e0	jsr $e0e9		jsr put_string
.e035	a9 82		lda #$82		lda #$82
.e037	8d 01 05	sta $0501		sta SID_BASE+$01	; frequency of voice 1 (high byte)
.e03a	a9 09		lda #$09		lda #$09
.e03c	8d 05 05	sta $0505		sta SID_BASE+$05	; attack and decay of voice 1
.e03f	a9 1e		lda #$1e		lda #$1e
.e041	8d 0f 05	sta $050f		sta SID_BASE+$0f	; freq of voice 3
.e044	a9 0f		lda #$0f		lda #$0f
.e046	8d 18 05	sta $0518		sta SID_BASE+$18	; max volume
.e049	a9 85		lda #$85		lda #$85
.e04b	8d 04 05	sta $0504		sta SID_BASE+$04	; play bell by opening gate on bit0 register #4
.e04e	ad 00 c2	lda $c200	-	lda $c200	; load a char from screen memory
.e051	1a		inc a			inc a		; increase value of accumulator
.e052	8d 00 c2	sta $c200		sta $c200	; store it back
.e055	a2 00		ldx #$00		ldx #$00	; init counter to 0
.e057	bd 80 03	lda $0380,x	-	lda $0380,x	; load key state
.e05a	9d 00 c4	sta $c400,x		sta $c400,x	; store it somewhere on screen
.e05d	e8		inx			inc x
.e05e	e0 49		cpx #$49		cpx #$49	; last key?
.e060	d0 f5		bne $e057		bne -
.e062	80 ea		bra $e04e		bra --
.e064					irq_handler:
.e064	48		pha			pha		; save processor state
.e065	da		phx			phx
.e066	5a		phy			phy
.e067	db		phz			phz
.e068	ba		tsx			tsx		; load sl into x
.e069	0b		tsy			tsy		; load sh into y
.e06a	86 f0		stx $f0			stx P0		; store sp into pointer register P0
.e06c	84 f1		sty $f1			sty P0+1
.e06e	a0 05		ldy #$05		ldy #$05	; index is $5
.e070	b1 f0		lda ($f0),y		lda (P0),y	; load the pushed status byte into accumulator
.e072	29 10		and #$10		and #%00010000	; was break "flag" present on stack?
.e074	f0 04		beq $e07a		beq +		; no: branch to normal irq part
.e076	ea		nop			nop		; blabla
.e077	ea		nop			nop		; blabla
.e078	80 21		bra $e09b		bra ++
.e07a	ad 00 03	lda $0300	+	lda CIA_BASE+0	; load current status
.e07d	29 80		and #$80		and #%10000000	; did CIA cause the interrupt?
.e07f	f0 1a		beq $e09b		beq +		; no: skip the next part
.e081	a9 01		lda #$01		lda #%00000001	;
.e083	8d 00 03	sta $0300		sta CIA_BASE+0	; acknowledge the interrupt
.e086	ad 00 03	lda $0300	-	lda CIA_BASE+0
.e089	29 01		and #$01		and #%00000001	; if bit 0 is on, a keyboard event is waiting
.e08b	f0 0e		beq $e09b		beq +		; no, skip the next part
.e08d	ad 02 03	lda $0302		lda CIA_BASE+2	; read a scancode
.e090	30 f4		bmi $e086		bmi -		; if bit 7 is set, check for a next event
.e092	aa		tax			tax		; move scancode into index register
.e093	bd 80 ff	lda $ff80,x		lda scancode_to_ascii,x		; lookup corresponding ascii value in table
.e096	20 cf e0	jsr $e0cf		jsr put_char
.e099	80 eb		bra $e086		bra -
.e09b	fb		plz		+	plz		; restore processor state
.e09c	7a		ply			ply
.e09d	fa		plx			plx
.e09e	68		pla			pla
.e09f	40		rti			rti		; return from interrupt
.e0a0					nmi_handler:
.e0a0	48		pha			pha
.e0a1	da		phx			phx
.e0a2	5a		phy			phy
.e0a3	db		phz			phz
.e0a4	fb		plz			plz
.e0a5	7a		ply			ply
.e0a6	fa		plx			plx
.e0a7	68		pla			pla
.e0a8	40		rti			rti
.e0a9					clear_screen:
.e0a9	a9 00		lda #$00		lda #$00
.e0ab	85 f0		sta $f0			sta P0
.e0ad	85 f2		sta $f2			sta P1
.e0af	a9 c0		lda #$c0		lda #$c0
.e0b1	85 f1		sta $f1			sta P0+1
.e0b3	a9 c8		lda #$c8		lda #$c8
.e0b5	85 f3		sta $f3			sta P1+1
.e0b7	a0 00		ldy #$00		ldy #$00
.e0b9	a9 20		lda #$20	-	lda #ASCII_SPACE
.e0bb	91 f0		sta ($f0),y		sta (P0),y
.e0bd	a9 0c		lda #$0c		lda #$0c	; grey
.e0bf	91 f2		sta ($f2),y		sta (P1),y
.e0c1	c8		iny			inc y
.e0c2	d0 f5		bne $e0b9		bne -
.e0c4	e6 f1		inc $f1			inc P0+1
.e0c6	e6 f3		inc $f3			inc P1+1
.e0c8	a6 f1		ldx $f1			ldx P0+1
.e0ca	e0 c8		cpx #$c8		cpx #$c8
.e0cc	d0 eb		bne $e0b9		bne -
.e0ce	60		rts			rts
.e0cf					put_char:
.e0cf	da		phx			phx
.e0d0	5a		phy			phy
.e0d1	c9 0a		cmp #$0a		cmp #ASCII_LF
.e0d3	f0 0f		beq $e0e4		beq +
.e0d5	aa		tax			tax
.e0d6	bd 00 ff	lda $ff00,x		lda ascii_to_screencode,x
.e0d9	a4 00		ldy $00			ldy cursor_pos
.e0db	99 00 c0	sta $c000,y		sta $c000,y
.e0de	c8		iny			inc y
.e0df	84 00		sty $00			sty cursor_pos
.e0e1	7a		ply			ply
.e0e2	fa		plx			plx
.e0e3	60		rts			rts
.e0e4	ea		nop		+	nop			; part in which LF is printed...
.e0e5	ea		nop			nop
.e0e6	7a		ply			ply
.e0e7	fa		plx			plx
.e0e8	60		rts			rts
.e0e9					put_string:
.e0e9	a0 00		ldy #$00		ldy #$00
.e0eb	e2 03		lda ($03,s),y	-	lda (#$03,s),y
.e0ed	f0 06		beq $e0f5		beq +
.e0ef	20 cf e0	jsr $e0cf		jsr put_char
.e0f2	c8		iny			inc y
.e0f3	80 f6		bra $e0eb		bra -
.e0f5	62 02		rts #$02	+	rtn #$02
>e0f7	45 36 34 20 28 43 29 32		welc1	.text "E64 (C)2019 by elmerucr",ASCII_NULL
>e0ff	30 31 39 20 62 79 20 65 6c 6d 65 72 75 63 72 00
>e10f	20 2d 20 6b 65 72 6e 65		welc2	.text " - kernel V20190829",ASCII_NULL
>e117	6c 20 56 32 30 31 39 30 38 32 39 00

;******  Processing file: E64_kernel_rom_tables.asm

.ff00					ascii_to_screencode
>ff00	80					.byte	$80		; 0x00 - NUL	non printable character
>ff01	80					.byte	$80		; 0x01 - SOH	non printable character
>ff02	80					.byte	$80		; 0x02 - STX	non printable character
>ff03	80					.byte	$80		; 0x03 - ETX	non printable character
>ff04	80					.byte	$80		; 0x04 - EOT	non printable character
>ff05	80					.byte	$80		; 0x05 - ENQ	non printable character
>ff06	80					.byte	$80		; 0x06 - ACK	non printable character
>ff07	80					.byte	$80		; 0x07 - BEL	non printable character
>ff08	80					.byte	$80		; 0x08 - BS	non printable character
>ff09	80					.byte	$80		; 0x09 - TAB	non printable character
>ff0a	80					.byte	$80		; 0x0a - LF	non printable character
>ff0b	80					.byte	$80		; 0x0b - VT	non printable character
>ff0c	80					.byte	$80		; 0x0c - FF	non printable character
>ff0d	80					.byte	$80		; 0x0d - CR	non printable character
>ff0e	80					.byte	$80		; 0x0e - SO	non printable character
>ff0f	80					.byte	$80		; 0x0f - SI	non printable character
>ff10	80					.byte	$80		; 0x10 - DLE	non printable character
>ff11	80					.byte	$80		; 0x11 - DC1	non printable character
>ff12	80					.byte	$80		; 0x12 - DC2	non printable character
>ff13	80					.byte	$80		; 0x13 - DC3	non printable character
>ff14	80					.byte	$80		; 0x14 - DC4	non printable character
>ff15	80					.byte	$80		; 0x15 - NAC	non printable character
>ff16	80					.byte	$80		; 0x16 - SYN	non printable character
>ff17	80					.byte	$80		; 0x17 - ETB	non printable character
>ff18	80					.byte	$80		; 0x18 - CAN	non printable character
>ff19	80					.byte	$80		; 0x19 - EM	non printable character
>ff1a	80					.byte	$80		; 0x1a - SUB	non printable character
>ff1b	80					.byte	$80		; 0x1b - ESC	non printable character
>ff1c	80					.byte	$80		; 0x1c - FS	non printable character
>ff1d	80					.byte	$80		; 0x1d - GS	non printable character
>ff1e	80					.byte	$80		; 0x1e - RS	non printable character
>ff1f	80					.byte	$80		; 0x1f - US	non printable character
>ff20	20					.byte	$20		; 0x20 - (space)
>ff21	21					.byte	$21		; 0x21 - !
>ff22	22					.byte	$22		; 0x22 - "
>ff23	23					.byte	$23		; 0x23 - #
>ff24	24					.byte	$24		; 0x24 - $
>ff25	25					.byte	$25		; 0x25 - %
>ff26	26					.byte	$26		; 0x26 - &
>ff27	27					.byte	$27		; 0x27 - '
>ff28	28					.byte	$28		; 0x28 - (
>ff29	29					.byte	$29		; 0x29 - )
>ff2a	2a					.byte	$2a		; 0x2a - *
>ff2b	2b					.byte	$2b		; 0x2b - +
>ff2c	2c					.byte	$2c		; 0x2c - ,
>ff2d	2d					.byte	$2d		; 0x2d - -
>ff2e	2e					.byte	$2e		; 0x2e - .
>ff2f	2f					.byte	$2f		; 0x2f - /
>ff30	30					.byte	$30		; 0x30 - 0
>ff31	31					.byte	$31		; 0x31 - 1
>ff32	32					.byte	$32		; 0x32 - 2
>ff33	33					.byte	$33		; 0x33 - 3
>ff34	34					.byte	$34		; 0x34 - 4
>ff35	35					.byte	$35		; 0x35 - 5
>ff36	36					.byte	$36		; 0x36 - 6
>ff37	37					.byte	$37		; 0x37 - 7
>ff38	38					.byte	$38		; 0x38 - 8
>ff39	39					.byte	$39		; 0x39 - 9
>ff3a	3a					.byte	$3a		; 0x3a - :
>ff3b	3b					.byte	$3b		; 0x3b - ;
>ff3c	3c					.byte	$3c		; 0x3c - <
>ff3d	3d					.byte	$3d		; 0x3d - =
>ff3e	3e					.byte	$3e		; 0x3e - >
>ff3f	3f					.byte	$3f		; 0x3f - ?
>ff40	00					.byte	$00		; 0x40 - @
>ff41	41					.byte	$41		; 0x41 - A
>ff42	42					.byte	$42		; 0x42 - B
>ff43	43					.byte	$43		; 0x43 - C
>ff44	44					.byte	$44		; 0x44 - D
>ff45	45					.byte	$45		; 0x45 - E
>ff46	46					.byte	$46		; 0x46 - F
>ff47	47					.byte	$47		; 0x47 - G
>ff48	48					.byte	$48		; 0x48 - H
>ff49	49					.byte	$49		; 0x49 - I
>ff4a	4a					.byte	$4a		; 0x4a - J
>ff4b	4b					.byte	$4b		; 0x4b - K
>ff4c	4c					.byte	$4c		; 0x4c - L
>ff4d	4d					.byte	$4d		; 0x4d - M
>ff4e	4e					.byte	$4e		; 0x4e - N
>ff4f	4f					.byte	$4f		; 0x4f - O
>ff50	50					.byte	$50		; 0x50 - P
>ff51	51					.byte	$51		; 0x51 - Q
>ff52	52					.byte	$52		; 0x52 - R
>ff53	53					.byte	$53		; 0x53 - S
>ff54	54					.byte	$54		; 0x54 - T
>ff55	55					.byte	$55		; 0x55 - U
>ff56	56					.byte	$56		; 0x56 - V
>ff57	57					.byte	$57		; 0x57 - W
>ff58	58					.byte	$58		; 0x58 - X
>ff59	59					.byte	$59		; 0x59 - Y
>ff5a	5a					.byte	$5a		; 0x5a - Z
>ff5b	1b					.byte	$1b		; 0x5b - [
>ff5c	5c					.byte	$5c		; 0x5c - \	patched
>ff5d	1d					.byte	$1d		; 0x5d - ]
>ff5e	5e					.byte	$5e		; 0x5e - ^	patched
>ff5f	5f					.byte	$5f		; 0x5f - _	patched
>ff60	63					.byte	$63		; 0x60 - `	patched
>ff61	01					.byte	$01		; 0x61 - a
>ff62	02					.byte	$02		; 0x62 - b
>ff63	03					.byte	$03		; 0x63 - c
>ff64	04					.byte	$04		; 0x64 - d
>ff65	05					.byte	$05		; 0x65 - e
>ff66	06					.byte	$06		; 0x66 - f
>ff67	07					.byte	$07		; 0x67 - g
>ff68	08					.byte	$08		; 0x68 - h
>ff69	09					.byte	$09		; 0x69 - i
>ff6a	0a					.byte	$0a		; 0x6a - j
>ff6b	0b					.byte	$0b		; 0x6b - k
>ff6c	0c					.byte	$0c		; 0x6c - l
>ff6d	0d					.byte	$0d		; 0x6d - m
>ff6e	0e					.byte	$0e		; 0x6e - n
>ff6f	0f					.byte	$0f		; 0x6f - o
>ff70	10					.byte	$10		; 0x70 - p
>ff71	11					.byte	$11		; 0x71 - q
>ff72	12					.byte	$12		; 0x72 - r
>ff73	13					.byte	$13		; 0x73 - s
>ff74	14					.byte	$14		; 0x74 - t
>ff75	15					.byte	$15		; 0x75 - u
>ff76	16					.byte	$16		; 0x76 - v
>ff77	17					.byte	$17		; 0x77 - w
>ff78	18					.byte	$18		; 0x78 - x
>ff79	19					.byte	$19		; 0x79 - y
>ff7a	1a					.byte	$1a		; 0x7a - z
>ff7b	64					.byte	$64		; 0x7b - {	patched
>ff7c	65					.byte	$65		; 0x7c - |	patched
>ff7d	66					.byte	$66		; 0x7d - }	patched
>ff7e	67					.byte	$67		; 0x7e - ~	patched
>ff7f	80					.byte	$80		; 0x7f - DEL	non printable character
.ff80					scancode_to_ascii:
>ff80	80					.byte	$80		; C256_SCANCODE_EMPTY
>ff81	80					.byte	$80		; C256_SCANCODE_ESCAPE
>ff82	80				    	.byte	$80		; C256_SCANCODE_F1,
>ff83	80					.byte	$80		; C256_SCANCODE_F2,
>ff84	80					.byte	$80		; C256_SCANCODE_F3,
>ff85	80					.byte	$80		; C256_SCANCODE_F4,
>ff86	80					.byte	$80		; C256_SCANCODE_F5,
>ff87	80					.byte	$80		; C256_SCANCODE_F6,
>ff88	80					.byte	$80		; C256_SCANCODE_F7,
>ff89	80					.byte	$80		; C256_SCANCODE_F8,
>ff8a	60					.byte	$60		; C256_SCANCODE_GRAVE,
>ff8b	31					.byte	$31		; C256_SCANCODE_1,
>ff8c	32					.byte	$32		; C256_SCANCODE_2,
>ff8d	33					.byte	$33		; C256_SCANCODE_3,
>ff8e	34					.byte	$34		; C256_SCANCODE_4,
>ff8f	35					.byte	$35		; C256_SCANCODE_5,
>ff90	36					.byte	$36		; C256_SCANCODE_6,
>ff91	37					.byte	$37		; C256_SCANCODE_7,
>ff92	38					.byte	$38		; C256_SCANCODE_8,
>ff93	39					.byte	$39		; C256_SCANCODE_9,
>ff94	30					.byte	$30		; C256_SCANCODE_0,
>ff95	2d					.byte	$2d		; C256_SCANCODE_MINUS,
>ff96	3d					.byte	$3d		; C256_SCANCODE_EQUALS,
>ff97	80					.byte	$80		; C256_SCANCODE_BACKSPACE,
>ff98	80					.byte	$80		; C256_SCANCODE_TAB,   please finish!
>ff99	71					.byte	$71		; C256_SCANCODE_Q,
>ff9a	77					.byte	$77		; C256_SCANCODE_W,
>ff9b	65					.byte	$65		; C256_SCANCODE_E,
>ff9c	72					.byte	$72		; C256_SCANCODE_R,
>ff9d	74					.byte	$74		; C256_SCANCODE_T,
>ff9e	79					.byte	$79		; C256_SCANCODE_Y,
.ff9f					hex_table
>ff9f	30 31 32 33 34 35 36 37			.text	"0123456789abcdef"
>ffa7	38 39 61 62 63 64 65 66

;******  Return to file: E64_kernel.asm

.fffa					nmi_vector:
>fffa	a0 e0					.word nmi_handler
.fffc					reset_vector:
>fffc	00 e0					.word cold_start
.fffe					brk_vector:
>fffe	64 e0					.word irq_handler

;******  End of listing
